<!doctype html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Kafka Interactive Presentation - PointCrush</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <link
            rel="stylesheet"
            as="style"
            crossorigin
            href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css"
        />
        <style>
            :root {
                --toss-blue: #0064ff;
                --toss-gray: #202632;
                --background-light: #f9fafb;
                --text-primary: #202632;
                --text-secondary: #4a5568;
                --card-bg: #ffffff;
                --border-color: #e2e8f0;
                --danger-color: #ef4444;
            }
            html {
                scroll-behavior: smooth;
            }
            body {
                font-family:
                    'Pretendard',
                    -apple-system,
                    BlinkMacSystemFont,
                    system-ui,
                    Roboto,
                    'Helvetica Neue',
                    'Segoe UI',
                    'Apple SD Gothic Neo',
                    'Noto Sans KR',
                    'Malgun Gothic',
                    'Apple Color Emoji',
                    'Segoe UI Emoji',
                    'Segoe UI Symbol',
                    sans-serif;
                background-color: var(--background-light);
                color: var(--text-primary);
                overflow-x: hidden;
            }
            .container-snap {
                scroll-snap-type: y mandatory;
                overflow-y: scroll;
                height: 100vh;
                margin-left: 60px;
            }
            .slide {
                width: calc(100vw - 60px);
                height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                padding: 4rem;
                scroll-snap-align: start;
                position: relative;
            }
            h1 {
                font-size: 4.5rem;
                line-height: 1.1;
                font-weight: 900;
            }
            h2 {
                font-size: 3.5rem;
                line-height: 1.2;
                font-weight: 800;
            }
            h3 {
                font-size: 1.875rem;
                line-height: 2.25rem;
                font-weight: 700;
            }
            h4 {
                font-size: 1.25rem;
                line-height: 1.75rem;
                font-weight: 600;
            }
            .slide-number {
                position: absolute;
                bottom: 2rem;
                right: 2rem;
                font-size: 1rem;
                font-weight: 500;
                color: #94a3b8;
            }
            .card {
                background-color: var(--card-bg);
                padding: 2rem;
                border-radius: 1rem;
                border: 1px solid var(--border-color);
                box-shadow:
                    0 4px 6px -1px rgb(0 0 0 / 0.1),
                    0 2px 4px -2px rgb(0 0 0 / 0.1);
                transition: all 0.3s ease;
            }
            .card:hover {
                transform: translateY(-5px) scale(1.02);
                box-shadow:
                    0 20px 25px -5px rgb(0 0 0 / 0.1),
                    0 8px 10px -6px rgb(0 0 0 / 0.1);
                background-image: linear-gradient(to top right, var(--card-bg), #f0f6ff);
            }
            .tab {
                cursor: pointer;
                padding: 0.75rem 1.5rem;
                transition: all 0.2s;
                border-bottom: 3px solid transparent;
                font-weight: 600;
                color: var(--text-secondary);
            }
            .tab.active {
                color: var(--toss-blue);
                border-bottom-color: var(--toss-blue);
            }
            .chart-container {
                position: relative;
                width: 100%;
                max-width: 450px;
                height: 300px;
            }
            #fullscreen-btn {
                position: fixed;
                top: 1.5rem;
                right: 1.5rem;
                z-index: 100;
                cursor: pointer;
                background-color: var(--card-bg);
                border: 1px solid var(--border-color);
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: flex;
                justify-content: center;
                align-items: center;
                transition: all 0.2s;
            }
            #fullscreen-btn:hover {
                background-color: #f1f5f9;
            }
            #fullscreen-btn svg {
                width: 20px;
                height: 20px;
                stroke: var(--text-secondary);
            }
            #side-nav {
                position: fixed;
                left: 0;
                top: 0;
                height: 100vh;
                width: 60px;
                background-color: rgba(255, 255, 255, 0.8);
                backdrop-filter: blur(10px);
                border-right: 1px solid var(--border-color);
                z-index: 50;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            .nav-dot {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background-color: #cbd5e1;
                margin: 8px 0;
                transition: all 0.3s ease;
                position: relative;
            }
            .nav-dot.active {
                background-color: var(--toss-blue);
                transform: scale(1.5);
            }
            .nav-dot .tooltip {
                position: absolute;
                left: 150%;
                top: 50%;
                transform: translateY(-50%);
                background-color: var(--toss-gray);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                white-space: nowrap;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }
            .nav-dot:hover .tooltip {
                opacity: 1;
                visibility: visible;
            }
            .revealable {
                opacity: 0;
                transform: translateY(20px);
                transition:
                    opacity 0.6s ease-out,
                    transform 0.6s ease-out;
            }
            .revealable.revealed {
                opacity: 1;
                transform: translateY(0);
            }

            .flow-animation-container {
                position: relative;
            }
            .message-flow {
                position: absolute;
                top: 20px;
                left: 10%;
                background-color: var(--toss-gray);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 12px;
                font-family: monospace;
                opacity: 0;
                white-space: nowrap;
            }
            .slide.active .message-flow {
                animation: flow 4s ease-in-out forwards;
            }
            @keyframes flow {
                0% {
                    opacity: 0;
                    transform: translateX(0);
                }
                10% {
                    opacity: 1;
                }
                40% {
                    transform: translateX(220%);
                }
                50% {
                    transform: translateX(220%);
                }
                90% {
                    transform: translateX(450%);
                }
                100% {
                    opacity: 0;
                    transform: translateX(450%);
                }
            }

            .sim-box {
                border: 2px solid var(--border-color);
                padding: 1rem;
                border-radius: 0.5rem;
                text-align: center;
                position: relative;
                overflow: hidden;
                transition: all 0.5s ease;
            }
            .sim-box.waiting {
                border-color: var(--danger-color);
                background-color: #fee2e2;
                animation: pulse 1s infinite;
            }
            .sim-box.failed {
                border-color: var(--danger-color);
                background-color: #fee2e2;
            }
            @keyframes pulse {
                50% {
                    background-color: #fecaca;
                }
            }

            .arrow-container {
                position: absolute;
                width: 100%;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
            }
            .arrow-line {
                height: 3px;
                transform-origin: left;
                transform: scaleX(0);
            }
            .arrow-head {
                position: absolute;
                right: -2px;
                top: -5px;
                width: 0;
                height: 0;
                border-top: 7px solid transparent;
                border-bottom: 7px solid transparent;
                border-left-width: 12px;
                opacity: 0;
            }
            .arrow-line.blue {
                background-color: var(--toss-blue);
            }
            .arrow-head.blue {
                border-left-color: var(--toss-blue);
            }
            .arrow-line.red {
                background-color: var(--danger-color);
            }
            .arrow-head.red {
                border-left-color: var(--danger-color);
            }

            .slide.active .arrow-container.admin-req .arrow-line {
                animation: spread 1s 0.5s forwards;
            }
            .slide.active .arrow-container.admin-req .arrow-head {
                animation: show-head 0.1s 1.5s forwards;
            }
            .slide.active .arrow-container.user-req .arrow-line {
                animation: spread 0.5s 2s forwards;
            }
            .slide.active .arrow-container.user-req .arrow-head {
                animation: show-head 0.1s 2.5s forwards;
            }
            .slide.active .arrow-container.api-fail .arrow-line {
                animation: spread 0.5s 2.8s forwards;
            }
            .slide.active .arrow-container.api-fail .arrow-head {
                animation: show-head 0.1s 3.3s forwards;
            }

            @keyframes spread {
                to {
                    transform: scaleX(1);
                }
            }
            @keyframes show-head {
                to {
                    opacity: 1;
                }
            }
        </style>
    </head>
    <body>
        <nav id="side-nav"></nav>

        <button id="fullscreen-btn" title="전체 화면 토글">
            <svg
                id="fs-enter-icon"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="2"
                stroke="currentColor"
            >
                <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"
                />
            </svg>
            <svg
                id="fs-exit-icon"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="2"
                stroke="currentColor"
                class="hidden"
            >
                <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25"
                />
            </svg>
        </button>

        <main class="container-snap">
            <div id="slide-1" class="slide text-center">
                <h1 class="revealable" style="color: var(--toss-blue)">함께 성장하는 크롤링 인프라</h1>
                <p class="mt-4 text-2xl text-slate-600 revealable" style="transition-delay: 0.1s">
                    Kafka 아키텍처 리뷰 및 학습 가이드
                </p>
                <div
                    class="mt-12 text-xl text-slate-500 max-w-3xl leading-relaxed revealable"
                    style="transition-delay: 0.2s"
                >
                    안녕하세요. 오늘 세미나에서는 제가 담당하고 있는 크롤링 인프라와,<br />
                    이를 지탱하는 핵심 기술인 <strong>Kafka</strong>에 대해 이야기해보려 합니다.<br />
                    우리 팀이 겪고 있는 문제를 어떻게 해결했는지, 그 과정에서 배운 것들을 공유합니다.
                </div>
                <div class="slide-number">1 / 15</div>
            </div>

            <div id="slide-2" class="slide">
                <h2 class="text-center mb-12 revealable">
                    "카프카가 없었다면?" #1:
                    <span style="color: var(--danger-color)">병목 현상</span>
                </h2>
                <div class="w-full max-w-5xl">
                    <p class="text-center text-lg text-slate-500 mb-8 revealable" style="transition-delay: 0.1s">
                        <strong>상황:</strong> Tor를 사용하는 느린 SEO 크롤링 100건이 <strong>동시에</strong>
                        요청되었습니다.
                    </p>
                    <div class="grid grid-cols-3 items-center gap-8">
                        <div
                            id="bottleneck-admin"
                            class="sim-box text-center revealable"
                            style="transition-delay: 0.2s"
                        >
                            <h4>어드민 API</h4>
                        </div>
                        <div class="relative">
                            <div class="arrow-container admin-req">
                                <div class="arrow-line blue"></div>
                                <div class="arrow-head blue"></div>
                            </div>
                        </div>
                        <div
                            id="bottleneck-crawler"
                            class="sim-box text-center revealable"
                            style="transition-delay: 0.4s"
                        >
                            <h4>크롤링 서버 (동기)</h4>
                        </div>
                    </div>
                    <div class="grid grid-cols-3 items-center gap-8 mt-12">
                        <div class="sim-box text-center revealable" style="transition-delay: 0.5s">
                            <h4>어드민 사용자</h4>
                        </div>
                        <div class="relative h-12">
                            <div class="arrow-container user-req" style="top: 15px">
                                <div class="arrow-line blue"></div>
                                <div class="arrow-head blue"></div>
                            </div>
                            <div
                                class="arrow-container api-fail"
                                style="top: 35px; transform: translateY(-50%) rotate(180deg)"
                            >
                                <div class="arrow-line red"></div>
                                <div class="arrow-head red"></div>
                            </div>
                        </div>
                        <div
                            id="bottleneck-api-placeholder"
                            class="sim-box text-center revealable"
                            style="transition-delay: 0.6s; border-style: dashed; color: #94a3b8"
                        >
                            <h4>(어드민 API 응답 대기)</h4>
                        </div>
                    </div>
                </div>
                <p class="mt-12 text-center text-lg text-slate-500 max-w-3xl revealable" style="transition-delay: 0.7s">
                    크롤링 서버가 응답할 때까지 어드민 API는 <strong>블로킹(Blocking)</strong>됩니다. 이 때문에 어드민
                    사용자의 다른 요청까지 처리하지 못하고 <strong>장애가 전파</strong>됩니다.
                </p>
                <div class="slide-number">2 / 15</div>
            </div>

            <div id="slide-3" class="slide">
                <h2 class="text-center mb-12 revealable">
                    "카프카가 없었다면?" #2:
                    <span style="color: var(--danger-color)">단일 실패 지점</span>
                </h2>
                <div class="w-full max-w-5xl">
                    <p class="text-center text-lg text-slate-500 mb-8 revealable" style="transition-delay: 0.1s">
                        <strong>상황:</strong> 단 하나뿐인 크롤링 서버 인스턴스에 예기치 않은 에러가 발생했습니다.
                    </p>
                    <div class="grid grid-cols-3 items-center gap-8">
                        <div class="sim-box text-center revealable" style="transition-delay: 0.2s">
                            <h4>어드민 API</h4>
                        </div>
                        <div class="relative">
                            <div class="arrow-container admin-req">
                                <div class="arrow-line blue"></div>
                                <div class="arrow-head blue"></div>
                            </div>
                        </div>
                        <div id="fault-crawler" class="sim-box text-center revealable" style="transition-delay: 0.4s">
                            <h4>크롤링 서버</h4>
                            <p class="text-sm text-slate-500"><span>정상 동작 중</span></p>
                        </div>
                    </div>
                </div>
                <p class="mt-12 text-center text-lg text-slate-500 max-w-3xl revealable" style="transition-delay: 0.5s">
                    만약 크롤링 서버가 다운된다면, 복구 전까지 <strong>모든 크롤링 관련 기능이 중단</strong>됩니다. 이는
                    서비스의 핵심 기능이 단 하나의 컴포넌트에 의존하는 <strong>단일 실패 지점(SPOF)</strong> 문제입니다.
                </p>
                <div class="slide-number">3 / 15</div>
            </div>

            <div id="slide-4" class="slide">
                <h2 class="text-center mb-12 revealable">
                    해결책:
                    <span style="color: var(--toss-blue)">시스템의 숨통 틔우기</span>
                </h2>
                <div class="flex items-center gap-8">
                    <div class="text-center revealable" style="transition-delay: 0.1s">
                        <h3 class="mb-4">강한 결합</h3>
                        <div class="card p-8">
                            <p>서버 ↔ 크롤러</p>
                            <p>서버 ↔ 알림</p>
                            <p>서버 ↔ 기타 서비스...</p>
                        </div>
                        <p class="mt-4 text-slate-500">한 곳의 장애가 전체로 전파</p>
                    </div>
                    <div class="text-center revealable" style="transition-delay: 0.2s">
                        <img
                            src="https://placehold.co/150x150/f0f6ff/0064FF?text=Event+Hub"
                            alt="Event Hub Concept"
                            class="rounded-full mx-auto"
                            onerror="
                                this.onerror = null;
                                this.src = 'https://placehold.co/150x150/e2e8f0/4a5568?text=Image';
                            "
                        />
                        <div class="text-5xl font-bold my-4" style="color: var(--toss-blue)">&rarr;</div>
                    </div>
                    <div class="text-center revealable" style="transition-delay: 0.3s">
                        <h3 class="mb-4">느슨한 결합</h3>
                        <div class="card p-8">
                            <p>
                                서버 &rarr;
                                <span class="font-bold" style="color: var(--toss-blue)">이벤트</span>
                                &larr; 크롤러
                            </p>
                            <p>
                                서버 &rarr;
                                <span class="font-bold" style="color: var(--toss-blue)">이벤트</span>
                                &larr; 알림
                            </p>
                            <p>
                                서버 &rarr;
                                <span class="font-bold" style="color: var(--toss-blue)">이벤트</span>
                                &larr; 기타 서비스...
                            </p>
                        </div>
                        <p class="mt-4 text-slate-500">독립적인 개발, 배포, 확장</p>
                    </div>
                </div>
                <p class="mt-12 text-center text-lg text-slate-500 max-w-3xl revealable" style="transition-delay: 0.4s">
                    이러한 문제를 해결하는 것이 바로 '디커플링'입니다. 중간에 <strong>메시지 큐</strong>라는 완충 지대를
                    두어, 서버와 크롤러가 서로의 상태에 영향을 받지 않도록 하는 것이죠. 이것이 우리 시스템 안정성의
                    핵심입니다.
                </p>
                <div class="slide-number">4 / 15</div>
            </div>

            <div id="slide-5" class="slide">
                <h2 class="text-center mb-12 revealable">메시지 큐, 그 다양한 선택지</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl">
                    <div class="card revealable" style="transition-delay: 0.1s">
                        <div class="flex items-center gap-4 mb-4">
                            <img
                                src="https://velog.velcdn.com/images/hyensukim/post/982900dc-1b5c-47e5-9478-74dc9fe2fd99/image.png"
                                alt="RabbitMQ Logo"
                                class="rounded-lg w-16 h-16 object-contain"
                            />
                            <h3 style="color: var(--toss-blue)">유사 기술들: RabbitMQ, SQS 등</h3>
                        </div>
                        <ul class="mt-4 list-disc list-inside space-y-2 text-slate-600">
                            <li>주로 '작업 큐' 관리에 중점을 둡니다.</li>
                            <li>복잡한 라우팅 규칙을 제공하기도 합니다.</li>
                            <li>일반적으로 메시지는 소비되면 사라집니다.</li>
                        </ul>
                    </div>
                    <div
                        class="card border-2 revealable"
                        style="
                            transition-delay: 0.2s;
                            border-color: var(--toss-blue);
                            box-shadow: 0 10px 15px -3px rgba(0, 100, 255, 0.1);
                        "
                    >
                        <div class="flex items-center gap-4 mb-4">
                            <img
                                src="https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202312/162433-1018/frame-1410115074.png"
                                alt="Kafka Logo"
                                class="rounded-lg w-16 h-16 object-contain"
                            />
                            <h3 style="color: var(--toss-blue)">우리 시스템의 Kafka</h3>
                        </div>
                        <ul class="mt-4 list-disc list-inside space-y-2 text-slate-600">
                            <li>대용량 데이터 스트림 처리에 최적화되어 있습니다.</li>
                            <li><strong>핵심 장점: 이벤트 저장소 역할.</strong></li>
                            <li>메시지를 디스크에 저장하여 장애 발생 시 재처리가 가능합니다.</li>
                        </ul>
                    </div>
                </div>
                <p class="mt-12 text-center text-lg text-slate-500 max-w-3xl revealable" style="transition-delay: 0.3s">
                    우리 시스템은 여러 메시지 큐 기술 중 Kafka를 채택했습니다. 그 덕분에 대규모 크롤링 요청을 안정적으로
                    처리하고, 문제가 발생했을 때 데이터를 유실하지 않고 다시 처리할 수 있는 능력을 갖추게 되었습니다.
                </p>
                <div class="slide-number">5 / 15</div>
            </div>

            <div id="slide-6" class="slide">
                <h2 class="text-center mb-12 revealable">
                    핵심 개념:
                    <span style="color: var(--toss-blue)">카프카의 구성 요소</span>
                </h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-6xl">
                    <div class="card revealable" style="transition-delay: 0.1s">
                        <h4>이벤트 (Event) & 토픽 (Topic)</h4>
                        <p class="mt-2 text-slate-500">
                            "어떤 일이 일어났다"는 기록. 이 이벤트들이 모여 특정 주제의 '토픽'을 이룹니다.
                        </p>
                        <p class="mt-4 text-sm bg-slate-100 p-3 rounded-md">
                            <strong>비유:</strong> 토픽은 '컴퓨터 과학'이라는 주제의 책, 이벤트는 그 책의 한
                            페이지입니다.
                        </p>
                    </div>
                    <div class="card revealable" style="transition-delay: 0.2s">
                        <h4>파티션 (Partition) & 오프셋 (Offset)</h4>
                        <p class="mt-2 text-slate-500">
                            토픽은 여러 '파티션'으로 나뉘어 병렬 처리를 가능하게 합니다. 파티션 내 메시지의 순서는
                            '오프셋'으로 보장됩니다.
                        </p>
                        <p class="mt-4 text-sm bg-slate-100 p-3 rounded-md">
                            <strong>비유:</strong> 파티션은 책의 '챕터', 오프셋은 챕터 안의 '페이지 번호'입니다.
                        </p>
                    </div>
                    <div class="card revealable" style="transition-delay: 0.3s">
                        <h4>프로듀서 (Producer) & 브로커 (Broker)</h4>
                        <p class="mt-2 text-slate-500">프로듀서는 이벤트를 생성하여 브로커(Kafka 서버)에게 보냅니다.</p>
                        <p class="mt-4 text-sm bg-slate-100 p-3 rounded-md">
                            <strong>비유:</strong> 프로듀서는 책의 '저자', 브로커는 책을 보관하는 '사서'입니다.
                        </p>
                    </div>
                    <div class="card revealable" style="transition-delay: 0.4s">
                        <h4>컨슈머 (Consumer) & 컨슈머 그룹</h4>
                        <p class="mt-2 text-slate-500">
                            컨슈머는 브로커로부터 이벤트를 가져와 처리합니다. 여러 컨슈머가 '그룹'을 이뤄 작업을
                            분담합니다.
                        </p>
                        <p class="mt-4 text-sm bg-slate-100 p-3 rounded-md">
                            <strong>비유:</strong> 컨슈머 그룹은 책을 나눠 읽는 '스터디 그룹'입니다.
                        </p>
                    </div>
                </div>
                <div class="slide-number">6 / 15</div>
            </div>

            <div id="slide-7" class="slide">
                <h2 class="text-center mb-12 revealable">
                    아키텍처 엿보기:
                    <span style="color: var(--toss-blue)">현재 우리 시스템</span>
                </h2>
                <div class="flex flex-col md:flex-row items-center gap-12 w-full max-w-6xl">
                    <div class="card flex-1 text-center revealable" style="transition-delay: 0.1s">
                        <h3>인프라 구성</h3>
                        <p class="text-4xl font-black mt-4" style="color: var(--toss-blue)">
                            1 <span class="text-2xl font-bold text-slate-700">Producer</span>
                        </p>
                        <p class="text-4xl font-black mt-2" style="color: var(--toss-blue)">
                            1 <span class="text-2xl font-bold text-slate-700">Broker</span>
                        </p>
                        <p class="text-4xl font-black mt-2" style="color: var(--toss-blue)">
                            29
                            <span class="text-2xl font-bold text-slate-700">Consumers</span>
                        </p>
                    </div>
                    <div class="card flex-1 revealable" style="transition-delay: 0.2s">
                        <h4 class="text-center mb-4">Consumer 역할 분배</h4>
                        <div class="chart-container mx-auto">
                            <canvas id="consumerDonutChart"></canvas>
                        </div>
                    </div>
                    <div class="card flex-1 revealable" style="transition-delay: 0.3s">
                        <h4 class="text-center mb-4">토픽별 할당 현황</h4>
                        <div class="chart-container mx-auto">
                            <canvas id="consumerBarChart"></canvas>
                        </div>
                    </div>
                </div>
                <div class="slide-number">7 / 15</div>
            </div>

            <div id="slide-8" class="slide">
                <h2 class="text-center mb-12 revealable">
                    워크플로우 1: <span style="color: var(--toss-blue)">작업의 시작</span>
                </h2>
                <div class="max-w-4xl w-full card revealable" style="transition-delay: 0.1s">
                    <div class="flex items-center gap-8 justify-center flow-animation-container">
                        <div class="message-flow">{"taskId": "abc-123", "url": "..."}</div>
                        <div class="text-center">
                            <p class="text-2xl font-bold">Express 서버</p>
                            <p class="text-slate-500">(요청 접수)</p>
                        </div>
                        <div class="text-4xl font-bold" style="color: var(--toss-blue)">&rarr;</div>
                        <div class="text-center">
                            <p class="text-2xl font-bold">NestJS 프로듀서</p>
                            <p class="text-slate-500">(API 호출)</p>
                        </div>
                        <div class="text-4xl font-bold" style="color: var(--toss-blue)">&rarr;</div>
                        <div class="text-center">
                            <p class="text-2xl font-bold">Kafka Broker</p>
                            <p class="text-slate-500">(이벤트 발행)</p>
                        </div>
                    </div>
                    <div class="mt-8">
                        <h4 style="color: var(--toss-blue)">1단계: 작업 요청 및 발행</h4>
                        <p class="mt-2 text-slate-600">
                            Express 서버가 요청을 받으면, NestJS 프로듀서에게 API를 호출합니다. 프로듀서는 해당 토픽으로
                            이벤트를 발행(emit)하고 즉시 응답합니다. 이를 'Fire-and-Forget'이라 하며, 서버가 긴 크롤링
                            작업을 기다리지 않게 해줍니다.
                        </p>
                    </div>
                </div>
                <div class="slide-number">8 / 15</div>
            </div>

            <div id="slide-9" class="slide">
                <h2 class="text-center mb-12 revealable">
                    워크플로우 2:
                    <span style="color: var(--toss-blue)">처리 및 보고</span>
                </h2>
                <div class="max-w-4xl w-full card revealable" style="transition-delay: 0.1s">
                    <div class="flex items-center gap-8 justify-center">
                        <div class="text-center">
                            <p class="text-2xl font-bold">NestJS 컨슈머</p>
                            <p class="text-slate-500">(크롤링 수행)</p>
                        </div>
                        <div class="text-4xl font-bold" style="color: var(--toss-blue)">&rarr;</div>
                        <div class="text-center">
                            <p class="text-2xl font-bold">Express 서버</p>
                            <p class="text-slate-500">(API 콜백)</p>
                        </div>
                        <div class="text-4xl font-bold" style="color: var(--toss-blue)">&rarr;</div>
                        <div class="text-center">
                            <p class="text-2xl font-bold">DB & 다음 단계</p>
                            <p class="text-slate-500">(결과 저장)</p>
                        </div>
                    </div>
                    <div class="mt-8">
                        <h4 style="color: var(--toss-blue)">2단계: 작업 처리 및 완료 보고</h4>
                        <p class="mt-2 text-slate-600">
                            컨슈머 그룹의 워커가 작업을 처리한 후, 카프카가 아닌 Express 서버의 API를 직접 호출하여
                            결과를 보고합니다. 이 '비대칭 통신 패턴'은 작업 결과가 중앙 서버에 확실히 기록되었음을
                            보장하는 신뢰성 높은 방법입니다.
                        </p>
                    </div>
                </div>
                <div class="slide-number">9 / 15</div>
            </div>

            <div id="slide-10" class="slide">
                <h2 class="text-center mb-12 revealable">
                    데이터는 어떻게 분배될까?:
                    <span style="color: var(--toss-blue)">파티셔닝 전략</span>
                </h2>
                <div class="card max-w-4xl w-full revealable" style="transition-delay: 0.1s">
                    <div class="flex justify-center border-b border-slate-200 mb-6">
                        <div id="tab-round-robin" class="tab active">라운드-로빈</div>
                        <div id="tab-key-based" class="tab">키 기반</div>
                        <div id="tab-custom" class="tab">커스텀</div>
                    </div>
                    <div id="content-round-robin" class="tab-content">
                        <h4 style="color: var(--toss-blue)">라운드-로빈 (기본 전략)</h4>
                        <p class="mt-2 text-slate-600">
                            메시지에 별도의 키가 없을 때 사용되며, 파티션에 순서대로 균등하게 분배됩니다. 처리량
                            극대화에 유리합니다.
                        </p>
                        <p class="mt-4 bg-blue-50 text-blue-700 p-3 rounded-md">
                            <strong>포인트크러쉬 적용:</strong> 현재 우리 시스템은 이 방식을 사용하여 모든 컨슈머에게
                            작업을 최대한 균등하게 분배하고 있습니다.
                        </p>
                    </div>
                    <div id="content-key-based" class="tab-content hidden">
                        <h4 style="color: var(--toss-blue)">키 기반 해시 (Hash Partitioning)</h4>
                        <p class="mt-2 text-slate-600">
                            메시지 키의 해시 값을 계산하여 특정 파티션에 할당합니다. 동일한 키를 가진 메시지는 항상
                            동일한 파티션으로 전송되어 처리 순서가 보장됩니다.
                        </p>
                        <p class="mt-4 text-sm bg-slate-100 p-3 rounded-md">
                            <strong>사용 예시:</strong> 사용자 ID를 키로 사용하면, 한 사용자의 모든 활동 로그를 순서대로
                            처리할 수 있습니다.
                        </p>
                    </div>
                    <div id="content-custom" class="tab-content hidden">
                        <h4 style="color: var(--toss-blue)">커스텀 파티셔너 (Custom Partitioner)</h4>
                        <p class="mt-2 text-slate-600">
                            개발자가 직접 파티션 할당 로직을 구현하는 방식입니다. 특정 비즈니스 규칙에 따라 데이터를
                            분배할 때 사용됩니다.
                        </p>
                        <p class="mt-4 text-sm bg-slate-100 p-3 rounded-md">
                            <strong>사용 예시:</strong> VIP 고객의 요청은 전용 파티션으로 보내 더 빠르게 처리하도록 할
                            수 있습니다.
                        </p>
                    </div>
                </div>
                <div class="slide-number">10 / 15</div>
            </div>

            <div id="slide-11" class="slide">
                <h2 class="text-center mb-12 revealable">
                    신뢰성의 비밀 1:
                    <span style="color: var(--toss-blue)">전송 보장 수준</span>
                </h2>
                <div class="card max-w-4xl w-full revealable" style="transition-delay: 0.1s">
                    <div class="flex justify-center border-b border-slate-200 mb-6">
                        <div id="tab-at-most" class="tab active">최대 한 번 (At-Most-Once)</div>
                        <div id="tab-at-least" class="tab">최소 한 번 (At-Least-Once)</div>
                        <div id="tab-exactly" class="tab">정확히 한 번 (Exactly-Once)</div>
                    </div>
                    <div id="content-at-most" class="tab-content">
                        <h4 style="color: var(--toss-blue)">최대 한 번 (At-Most-Once)</h4>
                        <p class="mt-2 text-slate-600">
                            메시지를 보내고 성공 여부를 확인하지 않습니다. 속도는 가장 빠르지만, 네트워크 장애 시
                            메시지가 유실될 수 있습니다.
                        </p>
                        <p class="mt-4 bg-blue-50 text-blue-700 p-3 rounded-md">
                            <strong>포인트크러쉬 적용:</strong> 현재 우리 프로듀서의 `emit` 방식은 여기에 해당합니다.
                            빠른 응답 속도를 얻는 대신, 드물게 작업 유실 가능성이 존재합니다.
                        </p>
                    </div>
                    <div id="content-at-least" class="tab-content hidden">
                        <h4 class="text-orange-500">최소 한 번 (At-Least-Once)</h4>
                        <p class="mt-2 text-slate-600">
                            성공 응답(ack)을 받을 때까지 재전송합니다. 데이터 유실은 없지만, 중복 처리 가능성이
                            있습니다. 대부분의 신뢰성 있는 시스템의 기본값입니다.
                        </p>
                    </div>
                    <div id="content-exactly" class="tab-content hidden">
                        <h4 class="text-green-500">정확히 한 번 (Exactly-Once)</h4>
                        <p class="mt-2 text-slate-600">
                            데이터의 유실이나 중복 없이 정확히 한 번만 처리됨을 보장합니다. 멱등성 프로듀서 설정을 통해
                            달성할 수 있습니다.
                        </p>
                    </div>
                </div>
                <div class="slide-number">11 / 15</div>
            </div>

            <div id="slide-12" class="slide">
                <h2 class="text-center mb-12 revealable">
                    신뢰성의 비밀 2:
                    <span style="color: var(--toss-blue)">수동 커밋의 힘</span>
                </h2>
                <div class="card max-w-4xl w-full revealable" style="transition-delay: 0.1s">
                    <h3 class="mb-4">"작업 완료"의 진짜 의미</h3>
                    <p class="text-slate-600 mb-4">
                        컨슈머에게 '작업 완료'란, 크롤링 성공이 아니라 '서버가 결과를 성공적으로 받았다고 확인해 준
                        시점'을 의미합니다. 이 시점을 제어하기 위해 수동 오프셋 커밋을 사용합니다.
                    </p>
                    <div class="bg-slate-800 text-white p-4 rounded-lg text-sm overflow-x-auto">
                        <pre><code class="language-js">
// 1. 메시지 처리 (크롤링)
const result = await doCrawling(message);

// 2. 서버에 결과 보고 (API 콜백)
const report = await reportToServer(result);

// 3. 서버 응답 성공 시에만 오프셋 커밋
if (report.success) {
  await consumer.commitOffsets();
}
// 4. 실패 시 커밋하지 않음 (재처리 유도)
                    </code></pre>
                    </div>
                    <p class="mt-4 text-slate-500">
                        이 패턴은 어떤 단계에서든 오류가 발생해도 작업이 유실되지 않고 안전하게 재처리될 수 있도록
                        보장하는 핵심 로직입니다.
                    </p>
                </div>
                <div class="slide-number">12 / 15</div>
            </div>

            <div id="slide-13" class="slide">
                <h2 class="text-center mb-12 revealable">
                    시스템 상태 측정하기:
                    <span style="color: var(--toss-blue)">컨슈머 랙</span>
                </h2>
                <div class="card max-w-4xl w-full revealable" style="transition-delay: 0.1s">
                    <h3 class="mb-4">컨슈머 랙 (Consumer Lag) 이란?</h3>
                    <p class="text-slate-600 mb-6">
                        프로듀서가 마지막으로 발행한 메시지의 오프셋과, 컨슈머 그룹이 마지막으로 처리한 메시지의 오프셋
                        간의 차이를 의미합니다. 즉,
                        <strong>처리해야 할 작업이 얼마나 밀려있는지</strong>를 나타내는 핵심 모니터링 지표입니다.
                    </p>
                    <div class="text-center p-6 bg-slate-50 rounded-lg">
                        <p>랙이 0에 가까우면 &rarr; 시스템이 원활하게 동작 중</p>
                        <p>
                            랙이 계속 증가하면 &rarr; 컨슈머의 처리 속도가 프로듀서를 따라가지 못하는 상태 (장애 또는
                            증설 필요)
                        </p>
                    </div>
                    <p class="mt-6 bg-yellow-50 text-yellow-800 p-3 rounded-md">
                        <strong>현재 우리의 한계:</strong> 프로듀서가 응답을 기다리지 않는 `emit` 방식을 사용하고 있어,
                        UI for Kafka 대시보드에서 컨슈머 랙이 `N/A`로 표시됩니다. 이는 현재 시스템의 제약 사항이며,
                        모니터링 고도화를 위해 앞으로 개선해야 할 지점입니다.
                    </p>
                </div>
                <div class="slide-number">13 / 15</div>
            </div>

            <div id="slide-14" class="slide">
                <h2 class="text-center mb-12 revealable">
                    현황 리뷰:
                    <span style="color: var(--toss-blue)">장점과 기술 부채</span>
                </h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-5xl">
                    <div class="card revealable" style="transition-delay: 0.1s">
                        <h3 class="mb-4" style="color: var(--toss-blue)">핵심 성과 (Pros)</h3>
                        <div class="space-y-4">
                            <div>
                                <h4>✅ 위기 대응 능력 (탄력적 확장성)</h4>
                                <p class="mt-1 text-slate-600">
                                    최근 미션 등록이 급증했을 때, 컨슈머 인스턴스를 몇 대 추가하는 것만으로 시스템 중단
                                    없이 트래픽을 감당해냈습니다.
                                </p>
                            </div>
                            <div>
                                <h4>✅ 용이한 디버깅 (로그 영속성)</h4>
                                <p class="mt-1 text-slate-600">
                                    카프카는 처리된 이벤트를 보관하므로, 특정 작업 실패 시 UI 대시보드를 통해 해당
                                    메시지를 다시 보며 원인을 분석하기 용이합니다.
                                </p>
                            </div>
                        </div>
                    </div>
                    <div class="card revealable" style="transition-delay: 0.2s">
                        <div class="flex items-start gap-4">
                            <h3 class="mb-4 text-orange-500">개선이 필요한 지점 (Cons)</h3>
                        </div>
                        <div class="space-y-4 mt-4">
                            <div>
                                <h4>⚠️ 모니터링 사각지대 (랙 확인 불가)</h4>
                                <p class="mt-1 text-slate-600">
                                    현재 프로듀서의 `emit` 방식 때문에 컨슈머가 얼마나 밀려있는지(랙)를 확인할 수 없어,
                                    직관적인 부하 모니터링이 어렵습니다.
                                </p>
                            </div>
                            <div>
                                <h4>⚠️ 되돌릴 수 없는 파티션 설정</h4>
                                <p class="mt-1 text-slate-600">
                                    과거에 순위 크롤링 토픽의 파티션이 잘못 증설되어, 현재 컨슈머 수와 파티션 할당
                                    비율이 맞지 않는 리소스 낭비가 발생하고 있습니다.
                                </p>
                            </div>
                            <div>
                                <h4>⚠️ 외부 의존성으로 인한 장애</h4>
                                <p class="mt-1 text-slate-600">
                                    SEO 크롤링에 사용되는 Tor IP 갱신 과정에서 타임아웃이 발생하면, 해당 컨슈머 전체가
                                    장애로 이어지는 경우가 있습니다.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="slide-number">14 / 15</div>
            </div>

            <div id="slide-15" class="slide text-center">
                <h2 class="mb-12 revealable">우리의 과제: <span style="color: var(--toss-blue)">TODO List</span></h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl w-full">
                    <div class="card text-left revealable" style="transition-delay: 0.1s">
                        <h4 style="color: var(--toss-blue)">1. 프로듀서 리팩토링</h4>
                        <p class="mt-1 text-slate-600">
                            `emit` 방식에서 `send` 방식으로 전환하여 `acks` 설정 및 멱등성 확보 방안을 모색합니다.
                        </p>
                    </div>
                    <div class="card text-left revealable" style="transition-delay: 0.2s">
                        <h4 style="color: var(--toss-blue)">2. 토픽 마이그레이션 전략 수립</h4>
                        <p class="mt-1 text-slate-600">
                            파티션 수가 잘못된 토픽의 데이터를 신규 토픽으로 이전하고, 기존 토픽을 제거하는 장기적
                            계획을 수립합니다.
                        </p>
                    </div>
                    <div class="card text-left revealable" style="transition-delay: 0.3s">
                        <h4 style="color: var(--toss-blue)">3. Dead Letter Queue (DLQ) 도입</h4>
                        <p class="mt-1 text-slate-600">
                            반복적으로 실패하는 메시지를 별도 토픽으로 분리하여, 전체 시스템의 안정성을 향상시킵니다.
                        </p>
                    </div>
                    <div class="card text-left revealable" style="transition-delay: 0.4s">
                        <h4 style="color: var(--toss-blue)">4. 모니터링 고도화</h4>
                        <p class="mt-1 text-slate-600">
                            컨슈머 랙(Lag)을 정밀하게 추적하고 임계치 초과 시 알림을 받는 시스템을 구축합니다.
                        </p>
                    </div>
                </div>
                <div class="slide-number">15 / 15</div>
            </div>
        </main>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const TOSS_BLUE = '#0064FF';
                const TOSS_GRAY = '#202632';
                const slides = document.querySelectorAll('.slide');
                const sideNav = document.getElementById('side-nav');

                // Create side navigation
                slides.forEach((slide) => {
                    const dot = document.createElement('a');
                    dot.href = `#${slide.id}`;
                    dot.classList.add('nav-dot');

                    const tooltip = document.createElement('span');
                    tooltip.classList.add('tooltip');
                    tooltip.textContent = slide.querySelector('h1, h2').innerText.split('\n')[0];
                    dot.appendChild(tooltip);

                    sideNav.appendChild(dot);
                });
                const navDots = document.querySelectorAll('.nav-dot');

                // Fullscreen functionality
                const fullscreenBtn = document.getElementById('fullscreen-btn');
                const enterIcon = document.getElementById('fs-enter-icon');
                const exitIcon = document.getElementById('fs-exit-icon');

                function toggleFullscreen() {
                    try {
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen();
                        } else if (document.exitFullscreen) {
                            document.exitFullscreen();
                        }
                    } catch (err) {
                        console.error('Fullscreen API is not supported or is disallowed by permissions policy.', err);
                    }
                }
                fullscreenBtn.addEventListener('click', toggleFullscreen);
                document.addEventListener('fullscreenchange', () => {
                    const isFullscreen = !!document.fullscreenElement;
                    enterIcon.classList.toggle('hidden', isFullscreen);
                    exitIcon.classList.toggle('hidden', !isFullscreen);
                });

                // Tab functionality
                const tabs = document.querySelectorAll('.tab');
                const tabContents = document.querySelectorAll('.tab-content');
                tabs.forEach((tab) => {
                    tab.addEventListener('click', () => {
                        tabs.forEach((t) => t.classList.remove('active'));
                        tabContents.forEach((c) => c.classList.add('hidden'));
                        tab.classList.add('active');
                        const targetId = 'content-' + tab.id.substring('tab-'.length);
                        const targetContent = document.getElementById(targetId);
                        if (targetContent) {
                            targetContent.classList.remove('hidden');
                        }
                    });
                });

                // Intersection Observer for animations and nav
                const observer = new IntersectionObserver(
                    (entries) => {
                        entries.forEach((entry) => {
                            const elements = entry.target.querySelectorAll('.revealable');
                            const id = entry.target.getAttribute('id');
                            if (entry.isIntersecting) {
                                entry.target.classList.add('active');
                                elements.forEach((el) => el.classList.add('revealed'));

                                const activeDot = document.querySelector(`.nav-dot[href="#${id}"]`);
                                if (activeDot) {
                                    navDots.forEach((dot) => dot.classList.remove('active'));
                                    activeDot.classList.add('active');
                                }

                                if (id === 'slide-2') {
                                    setTimeout(() => {
                                        const adminServer = document.getElementById('bottleneck-admin');
                                        if (adminServer) adminServer.classList.add('waiting');
                                    }, 1600);
                                }

                                if (id === 'slide-3') {
                                    setTimeout(() => {
                                        const crawlerServer = document.getElementById('fault-crawler');
                                        if (crawlerServer) {
                                            crawlerServer.classList.add('failed');
                                            const statusText = crawlerServer.querySelector('span');
                                            if (statusText) statusText.textContent = '장애 발생';
                                        }
                                    }, 2000);
                                }
                            } else {
                                entry.target.classList.remove('active');
                                if (id === 'slide-2') {
                                    const adminServer = document.getElementById('bottleneck-admin');
                                    if (adminServer) adminServer.classList.remove('waiting');
                                }
                                if (id === 'slide-3') {
                                    const crawlerServer = document.getElementById('fault-crawler');
                                    if (crawlerServer) {
                                        crawlerServer.classList.remove('failed');
                                        const statusText = crawlerServer.querySelector('span');
                                        if (statusText) statusText.textContent = '정상 동작 중';
                                    }
                                }
                            }
                        });
                    },
                    { threshold: 0.6 }
                );

                slides.forEach((slide) => observer.observe(slide));

                // Charts
                Chart.defaults.color = TOSS_GRAY;
                Chart.defaults.font.family = 'Pretendard';

                const consumerData = {
                    labels: ['최초 순위 정보', '상품 상세 정보(SEO)', '순위 갱신 정보'],
                    datasets: [
                        {
                            label: 'Consumer 할당',
                            data: [19, 6, 4],
                            backgroundColor: [TOSS_BLUE, 'rgba(0, 100, 255, 0.7)', 'rgba(0, 100, 255, 0.4)'],
                            borderColor: '#fff',
                            borderWidth: 4,
                        },
                    ],
                };

                new Chart(document.getElementById('consumerDonutChart').getContext('2d'), {
                    type: 'doughnut',
                    data: consumerData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: { padding: 20 },
                            },
                            tooltip: {
                                callbacks: { label: (ctx) => `${ctx.label}: ${ctx.raw}대` },
                            },
                        },
                    },
                });

                new Chart(document.getElementById('consumerBarChart').getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: ['최초 순위', 'SEO', '순위 갱신'],
                        datasets: [
                            {
                                label: '할당된 Consumer 수',
                                data: [19, 6, 4],
                                backgroundColor: [TOSS_BLUE, 'rgba(0, 100, 255, 0.7)', 'rgba(0, 100, 255, 0.4)'],
                                borderRadius: 5,
                            },
                        ],
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { grid: { color: '#e2e8f0' }, ticks: { color: TOSS_GRAY } },
                            y: {
                                beginAtZero: true,
                                grid: { color: '#e2e8f0' },
                                ticks: { color: TOSS_GRAY },
                            },
                        },
                        plugins: { legend: { display: false } },
                    },
                });
            });
        </script>
    </body>
</html>
